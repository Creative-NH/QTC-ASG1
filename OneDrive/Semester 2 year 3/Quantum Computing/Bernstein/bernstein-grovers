"""
NoiseDetectionEnhanced.py

This module simulates a toy noise detection algorithm using a Bernstein–Vazirani–style circuit.
It asks for a noise pattern (as a binary string), shows the BV process, simulates the circuit,
and finally outputs an arbitrary noise level in decibels along with a descriptive label.
"""
"""
Code explaination in lame man terms:

1) Ask the user for a noise pattern (a binary string).
2) Create an oracle that “encodes” that noise pattern by applying CNOT gates on a quantum circuit (one gate per '1' in the string).
3) Build a Bernstein–Vazirani–style circuit that uses the oracle to “read out” the noise pattern.
4) Simulate the circuit (using the AerSimulator) and print the measurement distribution along with the recovered noise pattern.
5) Compute an arbitrary “noise level” (in dB) based on the fraction of 1’s in the recovered noise pattern and provide a qualitative description (for example, “Average at home noise”).
"""

from qiskit_aer import AerSimulator
from qiskit import QuantumCircuit, transpile
from qiskit.circuit.instruction import Instruction
from typing import Tuple

def create_oracle_from_noise(noise_pattern: str) -> Instruction:
    """
    Create an oracle circuit that encodes the noise pattern.
    
    For every '1' in the noise pattern (read right-to-left), a CNOT gate is applied from
    the corresponding query qubit to the ancilla.
    
    Parameters:
        noise_pattern (str): The noise pattern as a binary string (e.g., "010101").
    
    Returns:
        Instruction: A reusable oracle instruction.
    """
    n = len(noise_pattern)  # number of bits in the noise pattern
    # Create a circuit with n+1 qubits (n query qubits, 1 ancilla) and n classical bits.
    oracle = QuantumCircuit(n + 1, n)
    
    # For each '1' in the noise pattern (reading from right-to-left), apply a CNOT.
    for index, bit in enumerate(reversed(noise_pattern)):
        if bit == "1":
            oracle.cx(index, n)
    
    inst = oracle.to_instruction()
    inst.name = "NoiseOracle"
    return inst

def construct_bv_circuit(oracle_inst: Instruction) -> QuantumCircuit:
    """
    Construct the full Bernstein–Vazirani circuit that uses the noise oracle.
    
    The process is:
      1. Apply Hadamard gates to the query qubits (to create a superposition).
      2. Prepare the ancilla in the |-> state.
      3. Append the noise oracle.
      4. Apply Hadamard gates again to the query qubits.
      5. Measure the query qubits.
    
    Parameters:
        oracle_inst (Instruction): The oracle encoding the noise pattern.
    
    Returns:
        QuantumCircuit: The complete BV circuit.
    """
    # Determine the number of query qubits (oracle_inst.num_qubits - 1)
    n = oracle_inst.num_qubits - 1  
    circuit = QuantumCircuit(n + 1, n)
    
    # Step 1: Apply Hadamard gates to all query qubits.
    print("Step 1: Applying Hadamard gates to query qubits.")
    for i in range(n):
        circuit.h(i)
    
    # Step 2: Prepare the ancilla in the |-> state.
    print("Step 2: Preparing the ancilla qubit in the |-> state (X then H).")
    circuit.x(n)
    circuit.h(n)
    circuit.barrier()
    
    # Step 3: Append the noise oracle.
    print("Step 3: Appending the noise oracle to the circuit.")
    circuit.append(oracle_inst, list(range(n+1)), list(range(n)))
    circuit.barrier()
    
    # Step 4: Apply Hadamard gates again to the query qubits.
    print("Step 4: Applying a second round of Hadamard gates to query qubits.")
    for i in range(n):
        circuit.h(i)
    circuit.barrier()
    
    # Step 5: Measure the query qubits.
    print("Step 5: Measuring the query qubits.")
    for i in range(n):
        circuit.measure(i, i)
    
    return circuit

def simulate_circuit(circuit: QuantumCircuit, shots: int = 1024) -> dict:
    """
    Simulate the circuit on the AerSimulator and return the measurement counts.
    
    Parameters:
        circuit (QuantumCircuit): The quantum circuit to simulate.
        shots (int): Number of shots (default 1024).
    
    Returns:
        dict: Measurement counts.
    """
    sim = AerSimulator()
    transpiled = transpile(circuit, sim)
    # Run the transpiled circuit directly (avoiding manual assembly of QasmQobj)
    result = sim.run(transpiled, shots=shots).result()
    counts = result.get_counts()
    return counts

def compute_noise_level(noise_pattern: str) -> Tuple[float, str]:
    """
    Compute an arbitrary noise level (in decibels) based on the noise pattern.
    
    For this toy model, assume the noise level is proportional to the fraction of 1's:
        noise_dB = (number of ones / total bits) * 100  (arbitrary scaling)
    
    Then, assign a qualitative description:
      - <20 dB: "Very Quiet (like a library)"
      - 20-50 dB: "Average at home noise"
      - 50-70 dB: "Busy street noise"
      - 70-90 dB: "Rock concert level"
      - >=90 dB: "Jet engine noise"
    
    Parameters:
        noise_pattern (str): The binary noise pattern.
    
    Returns:
        Tuple[float, str]: (noise level in dB, qualitative description)
    """
    n = len(noise_pattern)
    ones = noise_pattern.count('1')
    fraction = ones / n
    noise_db = fraction * 100  # arbitrary scaling factor for demonstration
    
    if noise_db < 20:
        description = "Very Quiet (like a library)"
    elif noise_db < 50:
        description = "Average at home noise"
    elif noise_db < 70:
        description = "Busy street noise"
    elif noise_db < 90:
        description = "Rock concert level"
    else:
        description = "Jet engine noise"
    
    return noise_db, description

def main():
    # Step 1: Ask the user for the noise pattern (binary string)
    noise_pattern = input("Enter the noise pattern as a binary string (e.g., 010101): ").strip()
    
    # Create the noise oracle from the pattern.
    oracle_inst = create_oracle_from_noise(noise_pattern)
    
    # Construct the full BV circuit and show its process.
    bv_circuit = construct_bv_circuit(oracle_inst)
    print("\nConstructed Bernstein–Vazirani Circuit:")
    print(bv_circuit.draw(output='text'))
    
    # Simulate the circuit.
    counts = simulate_circuit(bv_circuit)
    print("\nMeasurement Distribution:")
    print(counts)
    
    # Recover the noise pattern from the measurement (select the most frequent outcome).
    recovered_pattern = max(counts, key=counts.get)
    print("\nRecovered Noise Pattern:", recovered_pattern)
    
    # Compute the noise level in decibels and get a qualitative description.
    noise_db, description = compute_noise_level(recovered_pattern)
    print(f"\nComputed Noise Level: {noise_db:.2f} dB")
    print("Noise Level Description:", description)

if __name__ == "__main__":
    main()
